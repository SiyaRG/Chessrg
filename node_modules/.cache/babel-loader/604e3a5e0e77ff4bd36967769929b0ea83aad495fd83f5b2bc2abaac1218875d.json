{"ast":null,"code":"export const BFS = (tree, rootNode, destination, visited = [], queue = [rootNode]) => {\n  if (visited.indexOf(rootNode) !== -1) {\n    queue.shift();\n    rootNode = queue[0];\n  }\n  visited.append(rootNode);\n  queue.add(...tree[root]);\n  queue.shift();\n  if (rootNode === destination) {\n    return {\n      found: true,\n      checked: [visited]\n    };\n  } else if (queue.length === 0) {\n    return {\n      found: false,\n      checked: [visited]\n    };\n  } else {\n    return BFS(tree, queue[0], destination, visited, queue);\n  }\n};\n_c = BFS;\nexport const DFS = (tree, rootNode, destination, visited = [], stack = [rootNode]) => {\n  if (visited.indexOf(rootNode) !== -1) {\n    stack.pop();\n    rootNode = queue[queue.length - 1];\n  }\n  visited.add(rootNode);\n  stack.unshift(...tree[root]);\n  stack.shift();\n  if (rootNode === destination) {\n    return {\n      found: true,\n      checked: [visited]\n    };\n  } else if (stack.length === 0) {\n    return {\n      found: false,\n      checked: [visited]\n    };\n  } else {\n    return BFS(tree, stack[stack.length - 1], destination, visited, stack);\n  }\n};\n_c2 = DFS;\nexport const Djk = (graph, rootNode, destination, queue = [rootNode]) => {\n  rootNode.value = 0;\n  while (queue.length !== 0) {\n    queue.pop();\n    rootNode.cildren.forEach(child => {\n      if (graph[child[0]].value > rootNode.value + child[1]) {\n        graph[child[0]].value = rootNode.value + child[1];\n        graph[child[0]].sequence = [...rootNode.sequence, rootNode.name];\n        if (queue.indexOf(child[0]) !== -1) {\n          queue.add(child[0]);\n        }\n      }\n    });\n  }\n  return distance.seqence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\n_c3 = Djk;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"BFS\");\n$RefreshReg$(_c2, \"DFS\");\n$RefreshReg$(_c3, \"Djk\");","map":{"version":3,"names":["BFS","tree","rootNode","destination","visited","queue","indexOf","shift","append","add","root","found","checked","length","_c","DFS","stack","pop","unshift","_c2","Djk","graph","value","cildren","forEach","child","sequence","name","distance","seqence","_c3","$RefreshReg$"],"sources":["/data/data/com.termux/files/home/storage/projects/siya-app/src/Algorithms/Algorithms.js"],"sourcesContent":["export const BFS = (\n\ttree,\n\trootNode,\n\tdestination,\n\tvisited = [],\n\tqueue = [rootNode]\n) => {\n\tif (visited.indexOf(rootNode) !== -1) {\n\t\tqueue.shift();\n\t\trootNode = queue[0];\n\t}\n\tvisited.append(rootNode);\n\tqueue.add(...tree[root]);\n\tqueue.shift();\n\tif (rootNode === destination) {\n\t\treturn { found: true, checked: [visited] };\n\t} else if (queue.length === 0) {\n\t\treturn { found: false, checked: [visited] };\n\t} else {\n\t\treturn BFS(tree, queue[0], destination, visited, queue);\n\t}\n};\n\nexport const DFS = (\n\ttree,\n\trootNode,\n\tdestination,\n\tvisited = [],\n\tstack = [rootNode]\n) => {\n\tif (visited.indexOf(rootNode) !== -1) {\n\t\tstack.pop();\n\t\trootNode = queue[queue.length - 1];\n\t}\n\tvisited.add(rootNode);\n\tstack.unshift(...tree[root]);\n\tstack.shift();\n\tif (rootNode === destination) {\n\t\treturn { found: true, checked: [visited] };\n\t} else if (stack.length === 0) {\n\t\treturn { found: false, checked: [visited] };\n\t} else {\n\t\treturn BFS(tree, stack[stack.length - 1], destination, visited, stack);\n\t}\n};\nexport const Djk = (graph, rootNode, destination, queue = [rootNode]) => {\n\trootNode.value = 0;\n\twhile (queue.length !== 0) {\n\t\tqueue.pop();\n\t\trootNode.cildren.forEach(child => {\n\t\t\tif (graph[child[0]].value > rootNode.value + child[1]) {\n\t\t\t\tgraph[child[0]].value = rootNode.value + child[1];\n\t\t\t\tgraph[child[0]].sequence = [\n\t\t\t\t\t...rootNode.sequence,\n\t\t\t\t\trootNode.name\n\t\t\t\t];\n\t\t\t\tif (queue.indexOf(child[0]) !== -1) {\n\t\t\t\t\tqueue.add(child[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\treturn distance.seqence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}