{"ast":null,"code":"export const BFS = (tree, rootNode, destination, visited = [], queue = [rootNode]) => {\n  let count = 1;\n  while (rootNode !== null) {\n    while (queue.length !== 0 && visited.indexOf(rootNode) !== -1) {\n      queue.shift();\n      rootNode = queue.length !== 0 ? queue[0] : null;\n    }\n    if (rootNode !== null) {\n      visited.push(rootNode);\n      stack.shift();\n      stack.push(...tree[rootNode]);\n    }\n    if (rootNode === destination) {\n      return {\n        found: true,\n        checked: [...visited]\n      };\n    } else if (stack.length === 0) {\n      return {\n        found: false,\n        checked: [...visited]\n      };\n    } else {\n      rootNode = stack[0];\n    }\n  }\n};\n_c = BFS;\nexport const DFS = (tree, rootNode, destination, visited = [], stack = [rootNode]) => {\n  let count = 1;\n  while (rootNode !== null) {\n    while (stack.length !== 0 && visited.indexOf(rootNode) !== -1) {\n      stack.shift();\n      rootNode = stack.length !== 0 ? stack[0] : null;\n    }\n    if (rootNode !== null) {\n      visited.push(rootNode);\n      stack.shift();\n      stack.unshift(...tree[rootNode]);\n    }\n    if (rootNode === destination) {\n      return {\n        found: true,\n        checked: [...visited]\n      };\n    } else if (stack.length === 0) {\n      return {\n        found: false,\n        checked: [...visited]\n      };\n    } else {\n      rootNode = stack[0];\n    }\n  }\n  /*  \n  0: [10,1]\n  1:[0,11,2]\n  2:[1,12,3]\n  3:[2,13,4]\n  4:[3,14,5]\n  10:[20,11,0]\n  11:[10,21,12,1]\n  12:[11,22,13,2]\n  13:[12,23,14,3]\n  20:[30,21,10]\n  \n  rootNode: 20\n  visited: 0 10, 20\n  stack: 30,31,10,11,0, 1\n  \n  \n  */\n};\n_c2 = DFS;\nexport const Djk = (graph, rootNode, destination, queue = [rootNode]) => {\n  rootNode.value = 0;\n  while (queue.length !== 0) {\n    queue.pop();\n    rootNode.cildren.forEach(child => {\n      if (graph[child[0]].value > rootNode.value + child[1]) {\n        graph[child[0]].value = rootNode.value + child[1];\n        graph[child[0]].sequence = [...rootNode.sequence, rootNode.name];\n        if (queue.indexOf(child[0]) !== -1) {\n          queue.push(child[0]);\n        }\n      }\n    });\n  }\n  return destination.seqence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\n_c3 = Djk;\nexport const Astar = (tree, rootNode, destination, queue = [rootNode]) => {\n  for (let key in tree) {\n    key[\"h\"] = 2;\n  }\n};\n/*\ntree: {\"1\":{h: 5, g: 0,\n       prev: \"\", \n       children: [\"2\",6],[\"4\",1]},\n       \"2\":{h: 3, g: 0,\n       prev: \"\", \n       children: [\"7\",1],[\"2\",4]}\n  \n}\nrootNode: \"1\"\ndestination: \"100\"\n*/\n_c4 = Astar;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"BFS\");\n$RefreshReg$(_c2, \"DFS\");\n$RefreshReg$(_c3, \"Djk\");\n$RefreshReg$(_c4, \"Astar\");","map":{"version":3,"names":["BFS","tree","rootNode","destination","visited","queue","count","length","indexOf","shift","push","stack","found","checked","_c","DFS","unshift","_c2","Djk","graph","value","pop","cildren","forEach","child","sequence","name","seqence","_c3","Astar","key","_c4","$RefreshReg$"],"sources":["/data/data/com.termux/files/home/storage/projects/siya-app/src/Algorithms/Algorithms.js"],"sourcesContent":["export const BFS = (\n\ttree,\n\trootNode,\n\tdestination,\n\tvisited = [],\n\tqueue = [rootNode]\n) => {\n\tlet count = 1;\n\twhile (rootNode!==null) {\n\t\twhile (queue.length !== 0 && visited.indexOf(rootNode) !== -1) {\n\t\t\tqueue.shift();\n\t\t\trootNode = queue.length !== 0 ? queue[0] : null;\n\t\t}\n\n\t\tif (rootNode !== null) {\n\t\t\tvisited.push(rootNode);\n\t\t\tstack.shift();\n\t\t\tstack.push(...tree[rootNode]);\n\t\t}\n\t\tif (rootNode === destination) {\n\t\t\treturn {\n\t\t\t\tfound: true,\n\t\t\t\tchecked: [...visited]\n\t\t\t};\n\t\t} else if (stack.length === 0) {\n\t\t\treturn { found: false, checked: [...visited] };\n\t\t} else {\n\t\t\trootNode = stack[0];\n\t\t}\n\t}\n};\n\nexport const DFS = (\n\ttree,\n\trootNode,\n\tdestination,\n\tvisited = [],\n\n\tstack = [rootNode]\n) => {\n\tlet count = 1;\n\twhile (rootNode!==null) {\n\t\twhile (stack.length !== 0 && visited.indexOf(rootNode) !== -1) {\n\t\t\tstack.shift();\n\t\t\trootNode = stack.length !== 0 ? stack[0] : null;\n\t\t}\n\n\t\tif (rootNode !== null) {\n\t\t\tvisited.push(rootNode);\n\t\t\tstack.shift();\n\t\t\tstack.unshift(...tree[rootNode]);\n\t\t}\n\t\tif (rootNode === destination) {\n\t\t\treturn {\n\t\t\t\tfound: true,\n\t\t\t\tchecked: [...visited]\n\t\t\t};\n\t\t} else if (stack.length === 0) {\n\t\t\treturn { found: false, checked: [...visited] };\n\t\t} else {\n\t\t\trootNode = stack[0];\n\t\t}\n\t}\n\t/*  \n\t0: [10,1]\n\t1:[0,11,2]\n\t2:[1,12,3]\n\t3:[2,13,4]\n\t4:[3,14,5]\n\t10:[20,11,0]\n\t11:[10,21,12,1]\n\t12:[11,22,13,2]\n\t13:[12,23,14,3]\n\t20:[30,21,10]\n\t\n\trootNode: 20\n\tvisited: 0 10, 20\n\tstack: 30,31,10,11,0, 1\n\t\n\t\n\t*/\n};\nexport const Djk = (graph, rootNode, destination, queue = [rootNode]) => {\n\trootNode.value = 0;\n\twhile (queue.length !== 0) {\n\t\tqueue.pop();\n\t\trootNode.cildren.forEach(child => {\n\t\t\tif (graph[child[0]].value > rootNode.value + child[1]) {\n\t\t\t\tgraph[child[0]].value = rootNode.value + child[1];\n\t\t\t\tgraph[child[0]].sequence = [\n\t\t\t\t\t...rootNode.sequence,\n\t\t\t\t\trootNode.name\n\t\t\t\t];\n\t\t\t\tif (queue.indexOf(child[0]) !== -1) {\n\t\t\t\t\tqueue.push(child[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\treturn destination.seqence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\nexport const Astar = (tree, rootNode, destination, queue = [rootNode]) => {\n\tfor (let key in tree) {\n\t\tkey[\"h\"] = 2;\n\t}\n};\n/*\ntree: {\"1\":{h: 5, g: 0,\n       prev: \"\", \n       children: [\"2\",6],[\"4\",1]},\n       \"2\":{h: 3, g: 0,\n       prev: \"\", \n       children: [\"7\",1],[\"2\",4]}\n  \n}\nrootNode: \"1\"\ndestination: \"100\"\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}