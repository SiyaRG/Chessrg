{"ast":null,"code":"export const BFS = (tree, rootNode, destination, visited = [], queue = [rootNode]) => {\n  let count = 1;\n  while (rootNode !== null) {\n    while (queue.length !== 0 && visited.indexOf(rootNode) !== -1) {\n      queue.shift();\n      rootNode = queue.length !== 0 ? queue[0] : null;\n    }\n    if (rootNode !== null) {\n      visited.push(rootNode);\n      queue.shift();\n      queue.push(...tree[rootNode]);\n    }\n    if (rootNode === destination) {\n      return {\n        found: true,\n        checked: [...visited]\n      };\n    } else if (queue.length === 0) {\n      return {\n        found: false,\n        checked: [...visited]\n      };\n    } else {\n      rootNode = queue[0];\n    }\n  }\n};\n_c = BFS;\nexport const DFS = (tree, rootNode, destination, visited = [], stack = [rootNode]) => {\n  let count = 1;\n  while (rootNode !== null) {\n    while (stack.length !== 0 && visited.indexOf(rootNode) !== -1) {\n      stack.shift();\n      rootNode = stack.length !== 0 ? stack[0] : null;\n    }\n    if (rootNode !== null) {\n      visited.push(rootNode);\n      stack.shift();\n      stack.unshift(...tree[rootNode]);\n    }\n    if (rootNode === destination) {\n      return {\n        found: true,\n        checked: [...visited]\n      };\n    } else if (stack.length === 0) {\n      return {\n        found: false,\n        checked: [...visited]\n      };\n    } else {\n      rootNode = stack[0];\n    }\n  }\n  /*  \n  0: [10,1]\n  1:[0,11,2]\n  2:[1,12,3]\n  3:[2,13,4]\n  4:[3,14,5]\n  10:[20,11,0]\n  11:[10,21,12,1]\n  12:[11,22,13,2]\n  13:[12,23,14,3]\n  20:[30,21,10]\n  rootNode: 20\n  visited: 0 10, 20\n  stack: 30,31,10,11,0, 1\n  \t*/\n};\n_c2 = DFS;\nexport const Djk = (tree, rootNode, destination, queue = [rootNode]) => {\n  const graph = {};\n  for (let i = 0; i < tree.length; i++) {\n    let ch = [];\n    for (let j = 0; j < tree[i].length; j++) {\n      ch.push([Number(tree[i][j]), 1]);\n    }\n    graph[`${i}`] = {\n      value: 999999999,\n      sequence: [],\n      children: [...ch]\n    };\n  }\n  graph[rootNode].value = 0;\n  while (queue.length !== 0) {\n    rootNode = queue[0];\n    queue.shift();\n    graph[rootNode].children.forEach(child => {\n      if (graph[`${child[0]}`].value > graph[rootNode].value + child[1]) {\n        graph[`${child[0]}`].value = graph[rootNode].value + child[1];\n        graph[`${child[0]}`].sequence = [...graph[rootNode].sequence, rootNode];\n        queue.push(`${child[0]}`);\n      }\n    });\n  }\n  graph[destination].sequence = [...graph[destination].sequence, destination];\n  alert(JSON.stringify(graph));\n  alert(graph[destination].sequence);\n  return graph[destination].sequence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\n_c3 = Djk;\nexport const Astar = (tree, rootNode, destination, queue = [rootNode], visited = []) => {\n  const graph = {};\n  let dY = Math.floor(Number(destination) / 20);\n  let dX = Number(destination) % 20;\n  for (let i = 0; i < tree.length; i++) {\n    let ch = [];\n    for (let j = 0; j < tree[i].length; j++) {\n      ch.push([Number(tree[i][j]), 1]);\n    }\n    let iY = Math.floor(i / 20);\n    let iX = i % 20;\n    let h = Math.sqrt(Math.pow(iY - dY, 2) + Math.pow(iX - dX, 2));\n    graph[`${i}`] = {\n      value: 999999999,\n      sequence: [],\n      children: [...ch],\n      heuristic: h\n    };\n  }\n  graph[rootNode].value = 0;\n  while (queue.length !== 0 && graph[rootNode].heuristic !== 0) {\n    queue = queue.filter(node => {\n      return node !== rootNode;\n    });\n    let min = 999999999;\n    let nRoot = rootNode;\n    graph[rootNode].children.forEach(child => {\n      if (visited.indexOf(`${child[0]}`) === -1) {\n        graph[`${child[0]}`].value = graph[rootNode].value + child[1];\n        graph[`${child[0]}`].sequence = [...graph[rootNode].sequence, child[0]];\n        visited.push(`${child[0]}`);\n        queue.push(`${child[0]}`);\n      }\n    });\n    if (queue.length === 0) alert(\"yes\");\n    queue.forEach(prospect => {\n      if (graph[prospect].value + graph[prospect].heuristic < min) {\n        min = graph[prospect].value + graph[prospect].heuristic;\n        nRoot = prospect;\n      }\n    });\n    rootNode = nRoot;\n  }\n  alert(graph[destination].sequence);\n  return graph[destination].sequence;\n};\n/*\ntree: {\"1\":{h: 5, g: 0,\n       prev: \"\", \n       children: [\"2\",6],[\"4\",1]},\n       \"2\":{h: 3, g: 0,\n       prev: \"\", \n       children: [\"7\",1],[\"2\",4]}\n  \n}\nrootNode: \"1\"\ndestination: \"100\"\n*/\n_c4 = Astar;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"BFS\");\n$RefreshReg$(_c2, \"DFS\");\n$RefreshReg$(_c3, \"Djk\");\n$RefreshReg$(_c4, \"Astar\");","map":{"version":3,"names":["BFS","tree","rootNode","destination","visited","queue","count","length","indexOf","shift","push","found","checked","_c","DFS","stack","unshift","_c2","Djk","graph","i","ch","j","Number","value","sequence","children","forEach","child","alert","JSON","stringify","_c3","Astar","dY","Math","floor","dX","iY","iX","h","sqrt","pow","heuristic","filter","node","min","nRoot","prospect","_c4","$RefreshReg$"],"sources":["/data/data/com.termux/files/home/storage/projects/siya-app/src/Algorithms/Algorithms.js"],"sourcesContent":["export const BFS = (\n    tree,\n    rootNode,\n    destination,\n    visited = [],\n    queue = [rootNode]\n) => {\n    let count = 1;\n    while (rootNode !== null) {\n        while (queue.length !== 0 && visited.indexOf(rootNode) !== -1) {\n            queue.shift();\n            rootNode = queue.length !== 0 ? queue[0] : null;\n        }\n\n        if (rootNode !== null) {\n            visited.push(rootNode);\n            queue.shift();\n            queue.push(...tree[rootNode]);\n        }\n        if (rootNode === destination) {\n            return {\n                found: true,\n                checked: [...visited]\n            };\n        } else if (queue.length === 0) {\n            return { found: false, checked: [...visited] };\n        } else {\n            rootNode = queue[0];\n        }\n    }\n};\n\nexport const DFS = (\n    tree,\n    rootNode,\n    destination,\n    visited = [],\n    stack = [rootNode]\n) => {\n    let count = 1;\n    while (rootNode !== null) {\n        while (stack.length !== 0 && visited.indexOf(rootNode) !== -1) {\n            stack.shift();\n            rootNode = stack.length !== 0 ? stack[0] : null;\n        }\n\n        if (rootNode !== null) {\n            visited.push(rootNode);\n            stack.shift();\n            stack.unshift(...tree[rootNode]);\n        }\n        if (rootNode === destination) {\n            return {\n                found: true,\n                checked: [...visited]\n            };\n        } else if (stack.length === 0) {\n            return { found: false, checked: [...visited] };\n        } else {\n            rootNode = stack[0];\n        }\n    }\n    /*  \n\t0: [10,1]\n\t1:[0,11,2]\n\t2:[1,12,3]\n\t3:[2,13,4]\n\t4:[3,14,5]\n\t10:[20,11,0]\n\t11:[10,21,12,1]\n\t12:[11,22,13,2]\n\t13:[12,23,14,3]\n\t20:[30,21,10]\n\t\n\trootNode: 20\n\tvisited: 0 10, 20\n\tstack: 30,31,10,11,0, 1\n\t\n\t\n\t*/\n};\nexport const Djk = (tree, rootNode, destination, queue = [rootNode]) => {\n    const graph = {};\n\n    for (let i = 0; i < tree.length; i++) {\n        let ch = [];\n        for (let j = 0; j < tree[i].length; j++) {\n            ch.push([Number(tree[i][j]), 1]);\n        }\n        graph[`${i}`] = { value: 999999999, sequence: [], children: [...ch] };\n    }\n\n    graph[rootNode].value = 0;\n\n    while (queue.length !== 0) {\n        rootNode = queue[0];\n        queue.shift();\n\n        graph[rootNode].children.forEach(child => {\n            if (graph[`${child[0]}`].value > graph[rootNode].value + child[1]) {\n                graph[`${child[0]}`].value = graph[rootNode].value + child[1];\n                graph[`${child[0]}`].sequence = [\n                    ...graph[rootNode].sequence,\n                    rootNode\n                ];\n\n                queue.push(`${child[0]}`);\n            }\n        });\n    }\n    graph[destination].sequence = [...graph[destination].sequence, destination];\n    alert(JSON.stringify(graph));\n    alert(graph[destination].sequence);\n    return graph[destination].sequence;\n};\n\n/*\n                  1 \n               5     8 \n             13 6 0 7  11\n              20\n             3\n          \n          {\n            1: [[5,17],[8,3]],\n            5: [[13,7],[6,1],[1,17]],\n            8 :[[7,5],[11,1],[1,3]],\n            13:[[20,1],[5,7],\n            6: [[20,5],[0,3],[5,1]],\n            0: [[6,3],[7,1]],\n            7: [[0,1],[11,4]],\n            11: [[8,1],[7,4]],\n            20: [[13,1],[6,5],[3,27]],\n            3: [[20,27]]\n          }\n         .....\n         object: \n         rootNode: \n         currentNode: \n         queue: \n         \n         1: {0,[1]}\n         5:{13,[1,8,7,0,6,5]}\n         8:{3,[1,8]}\n         13:{18,[1,8,7,0,6,20,13]}\n         6:{12,[1,8,7,0,6]}\n         7: {8,[1,8,7]}\n         11: {4,[1,8,11]}\n         20: {17,[1,8,7,0,6,20]}\n         0: {9,[1,8,7,0]}\n         3: {44,[1,8,7,0,6,20]}\n         \n         \n        while queue !empty\n         check if (current dist + difference) < child distance\n          {\n            update child value\n            child sequenc= [...parentSeq,child]\n          if not in queue  add Child to queue\n          }\n          return object[destination]\n          ...........\n          \n         \n */\nexport const Astar = (\n    tree,\n    rootNode,\n    destination,\n    queue = [rootNode],\n    visited = []\n) => {\n    const graph = {};\n    let dY = Math.floor(Number(destination) / 20);\n    let dX = Number(destination) % 20;\n    for (let i = 0; i < tree.length; i++) {\n        let ch = [];\n\n        for (let j = 0; j < tree[i].length; j++) {\n            ch.push([Number(tree[i][j]), 1]);\n        }\n        let iY = Math.floor(i / 20);\n        let iX = i % 20;\n        let h = Math.sqrt(Math.pow(iY - dY, 2) + Math.pow(iX - dX, 2));\n        graph[`${i}`] = {\n            value: 999999999,\n            sequence: [],\n            children: [...ch],\n            heuristic: h\n        };\n    }\n    graph[rootNode].value = 0;\n\n    while (queue.length !== 0 && graph[rootNode].heuristic !== 0) {\n        queue = queue.filter(node => {\n            return node !== rootNode;\n        });\n        let min = 999999999;\n        let nRoot = rootNode;\n        graph[rootNode].children.forEach(child => {\n            if (visited.indexOf(`${child[0]}`) === -1) {\n                graph[`${child[0]}`].value = graph[rootNode].value + child[1];\n                graph[`${child[0]}`].sequence = [\n                    ...graph[rootNode].sequence,\n                    child[0]\n                ];\n                visited.push(`${child[0]}`);\n                queue.push(`${child[0]}`);\n            }\n        });\n        if (queue.length === 0) alert(\"yes\");\n        queue.forEach(prospect => {\n            if (graph[prospect].value + graph[prospect].heuristic < min) {\n                min = graph[prospect].value + graph[prospect].heuristic;\n                nRoot = prospect;\n            }\n        });\n        rootNode = nRoot;\n    }\n    alert(graph[destination].sequence);\n    return graph[destination].sequence;\n};\n/*\ntree: {\"1\":{h: 5, g: 0,\n       prev: \"\", \n       children: [\"2\",6],[\"4\",1]},\n       \"2\":{h: 3, g: 0,\n       prev: \"\", \n       children: [\"7\",1],[\"2\",4]}\n  \n}\nrootNode: \"1\"\ndestination: \"100\"\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}